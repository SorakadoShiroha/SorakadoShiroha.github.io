{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"AcWing 3841.阶乘的和","date":"2025-01-22T07:55:36.627Z","updated":"2025-01-22T11:42:07.709Z","comments":true,"path":"2025/01/22/AcWing 3841.阶乘的和/","permalink":"http://example.com/2025/01/22/AcWing%203841.%E9%98%B6%E4%B9%98%E7%9A%84%E5%92%8C/","excerpt":"","text":"AcWing 3841.阶乘的和计算阶乘并保存：123456for (int i = 0; i &lt; 10; i++) &#123; f[i] = 1; // 初始化 f[i]。 for (int j = i; j &gt; 0; j--) &#123; // 计算阶乘。 f[i] *= j; &#125;&#125; 从f[0]到f[10]保存了0!到10!阶乘的计算过程：f[i]&#x3D;1 –&gt; f[i]&#x3D;f[i]*j (j&#x3D;i,j–) 例：1*5*4*3*2*1 计算阶乘之和判断n是否可以由1-10的阶乘中，若干个元素相加得到？ 123456789for (int i = 1; i &lt; (1 &lt;&lt; 10); i++) &#123;//遍历所有子集，i&lt;1024 int s = 0; for (int j = 0; j &lt; 10; j++) &#123; if (i &gt;&gt; j &amp; 1) &#123; // 检查第 j 位是否为 1。 s += f[j]; &#125; &#125; S.insert(s); // 插入子集和。 &#125; 题目：n&#x3D; f[x1]+f[x2]+…f[xi] （x&gt;0）即从f[1]到f[10]中，任选几项相加 如何抽出几项？ 一共有10项，可以使用二进制求解。将“1”表示为被抽出，“0”表示为未被抽出。例：000010011表示n&#x3D;f[x5]+f[x2]+f[x1] 解析代码：1for (int i = 1; i &lt; (1 &lt;&lt; 10); i++) 一共10项，即10位，若为1则对应位的f[xi]生效。10位二进制可以表示范围为0-1023，i的范围为 0000000001 ——1111111111（1—1023） 1234for (int j = 0; j &lt; 10; j++) &#123; if (i &gt;&gt; j &amp; 1) &#123; // 检查第 j 位是否为 1。 s += f[j]; &#125; j属于0-9，i&gt;&gt;j表示对i右移，&amp;1表示对1与。j&#x3D;0时，i不移动，例100010011&amp;1j&#x3D;1时，i右移1位，0100101001&amp;1j&#x3D;4时，i右移4位，0000100001&amp;1 示例： 1234int i = 5;//0000 0101for (int j = 0; j &lt; 4; j++) &#123; cout &lt;&lt; (i &gt;&gt; j &amp;1) &lt;&lt; &quot; &quot;;&#125; out: 1 0 1 0 示例2： 12int j = 45;//0010 1101cout &lt;&lt; (j &amp; 0b111) &lt;&lt; &#x27; &#x27; &lt;&lt; (j &amp; 7) &lt;&lt; &#x27; &#x27; &lt;&lt; (j &amp; 0b11)&lt;&lt;&#x27; &#x27;&lt;&lt;(j &amp; 0b1111); out:5 5 1 13 即若i的第j+1位为1，则加上f[j]，即计算阶乘之和。例如，i循环到0000010010时，s&#x3D;f[1]+f[5]。每计算完一次i则加入set中。所以，通过i从0000000000到1111111111的循环，所有的相加可能性均会被加入到set当中。","categories":[],"tags":[]}],"categories":[],"tags":[]}