{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"友情链接","date":"2025-01-23T01:11:24.350Z","updated":"2025-01-23T01:11:24.350Z","comments":true,"path":"friend/index.html","permalink":"http://example.com/friend/index.html","excerpt":"","text":"本站信息 站名： 拔剑Sketon 站长： 拔剑Sketon 地址： https://d-sketon.top/ 备用地址：https://d-sketon.github.io/ 申请方法 添加本站后，在本页留言，格式如下 123456```yml- name: #您的名字 url: #您的网址 desc: #简短描述 image: #一张图片``` 小伙伴们 D-Sketon 一个车万人"},{"title":"关于","date":"2021-09-22T13:01:47.000Z","updated":"2025-01-23T01:11:24.303Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"关于"}],"posts":[{"title":"AcWing 3555. 二叉树","slug":"二叉树","date":"2025-02-21T08:34:54.000Z","updated":"2025-02-21T10:06:49.613Z","comments":true,"path":"2025/02/21/二叉树/","permalink":"http://example.com/2025/02/21/%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"题目给定一个 nn 个结点（编号 1∼n1∼n）构成的二叉树，其根结点为 11 号点。 进行 mm 次询问，每次询问两个结点之间的最短路径长度。 树中所有边长均为 11。 输入格式第一行包含一个整数 TT，表示共有 TT 组测试数据。 每组数据第一行包含两个整数 n,mn,m。 接下来 nn 行，每行包含两个整数，其中第 ii 行的整数表示结点 ii 的子结点编号。如果没有子结点则输出 −1−1。 接下来 mm 行，每行包含两个整数，表示要询问的两个结点的编号。 输出格式每组测试数据输出 mm 行，代表查询的两个结点之间的最短路径长度。 输入样例：123456789101112131418 42 34 56 -1-1 -1-1 7-1 -18 -1-1 -11 64 64 58 1 输出样例：12342424 题解用例的树如下。 如何建树？ 1234567891011121314const int N = 1010;int n, m;int l[N], r[N], p[N];int dist[N]; memset(l, -1, sizeof 1);memset(r, -1, sizeof 1);for (int i = 1; i &lt;= n; i++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; l[i] = a, r[i] = b; if (a != -1) p[a] = i; if (b != -1) p[b] = i;&#125; 按组输入a，b表示当前节点的左孩子和右孩子。l[1]&#x3D;2,r[1]&#x3D;3,p[2]&#x3D;p[3]&#x3D;1–&gt;l[2]&#x3D;4,r[2]&#x3D;5,p[4]&#x3D;p[5]&#x3D;2。–&gt;l[3]&#x3D;6,r[3]&#x3D;-1,p[6]&#x3D;3–&gt;l[4]&#x3D;-1,r[4]&#x3D;-1。–&gt;l[5]&#x3D;-1,r[5]&#x3D;7,p[7]&#x3D;5–&gt;l[6]&#x3D;8,r[6]&#x3D;-1,p[8]&#x3D;6 在每一轮循环中，输入第i个节点的两个孩子节点，-1表示空节点，保存在l[i]和r[i]中，同时，若输入的节点不为-1，则p[]&#x3D;i，保存输入节点的父节点。 计算距离1首先计算各个节点到根节点的距离 123456void dfs(int u, int d) &#123; dist[u] = d; if (l[u] != -1) dfs(l[u], d + 1); if (r[u] != -1) dfs(r[u], d + 1);&#125;dfs(1, 0); 调用dfs。u代表节点，d代表距离，dist[u]代表该节点距离根节点的距离。初始参数1，0，根节点距离自己的距离为0。若其左孩子不为空，则递归调用，且每调用一次距离就加一。调用至-1后往右走。走到底返回上一层再往右。。。 计算距离2找到欲求两个节点的公共祖先 123456int get_lca(int a, int b) &#123; if (dist[a] &gt; dist[b]) swap(a, b);//默认a在上b在下 while (dist[a] &lt; dist[b]) b = p[b];//若b在下，则b=b的父节点，往上爬直到和a平齐 while (a != b) a = p[a], b = p[b];//ab走不到一起，同时往上走 return a;&#125; cout &lt;&lt; dist[a] + dist[b] - dist[lca] * 2&lt;&lt;endl;","categories":[],"tags":[]},{"title":"二叉树先序建树，中序遍历","slug":"二叉树先序建树，中序遍历","date":"2025-02-19T08:30:19.000Z","updated":"2025-02-20T09:46:35.971Z","comments":true,"path":"2025/02/19/二叉树先序建树，中序遍历/","permalink":"http://example.com/2025/02/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%85%88%E5%BA%8F%E5%BB%BA%E6%A0%91%EF%BC%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/","excerpt":"","text":"题目编一个程序，读入用户输入的一串先序遍历字符串，根据此字符串建立一个二叉树（以指针方式存储）。 例如如下的先序遍历字符串： ABC##DE#G##F### 其中“#”表示的是空格，空格字符代表空树。建立起此二叉树以后，再对二叉树进行中序遍历，输出遍历结果。 代码1234567891011121314151617181920212223242526272829303132333435#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;const int N1 = 1e8 + 5;const int N2 = 1e2 + 5;int pos, len, t;char tree[N1];char str[N2];void create(int pos)//建立二叉树&#123; char c = str[t++]; if (c == &#x27;#&#x27;)//若是‘#’，说明该节点为空返回上一级节点 return; tree[pos] = c;//若不是‘#’，为本节点赋值 create(pos * 2);//递归创建左子树 create(pos * 2 + 1);//递归创建右子树&#125;void traverse(int root)//中序遍历二叉树&#123; if (tree[root] == 0)//如果该节点为0，说明该节点为空，返回上一级 return; traverse(2 * root);//先遍历左子树 printf(&quot;%c &quot;, tree[root]);//遍历完左子树后，访问本节点 traverse(2 * root + 1);//再遍历右子树&#125;int main()&#123; while (scanf(&quot;%s&quot;, str) != EOF) &#123; t = 0; create(1); traverse(1); printf(&quot;\\n&quot;); &#125;&#125; 用例执行逻辑输入ABC##DE#G##F### ，进入create函数。判断当前字符是否为#，若不是，则为本节点赋值。赋值后，递归调用create函数，方向一路朝左。若当前字符为#，则return（至上一层）。函数继续向下运行，调用create ，这次是右子树。 A–&gt;A左孩子B–&gt;B左孩子C–&gt;C左孩子#—&gt;返回–&gt;C右孩子#—&gt;返回 –&gt; B右孩子D–&gt;D左孩子E–&gt;E左孩子#–&gt;返回–&gt;E右孩子G–&gt;G左孩子#–&gt;返回–&gt;G右孩子#–&gt;返回 –&gt;D右孩子F–&gt;F双返回–&gt;D右孩子— – –&gt;返回— –&gt;A右孩子#–&gt;返回全 遍历一路最左，发现0空节点，返回上层打印，走到最左边后该往右走了。 A–&gt;A左孩子B–&gt;B左孩子C–&gt;C左孩子空—&gt;返回–&gt; 打印C–&gt;C右孩子空—&gt;函数到底返回–&gt; 打印B–&gt; B右孩子D–&gt;D左孩子E–&gt;E左孩子空–&gt;返回–&gt; 打印E–&gt;E右孩子G–&gt;G左孩子空–&gt;返回 打印G–&gt;G右孩子空–&gt;函数到底返回–&gt;E到右孩子到底返回–&gt; –&gt;打印D–&gt;D右孩子F–&gt;F左孩子空–&gt;返回–&gt; –&gt;打印F–&gt;F左孩子空–&gt;函数到底返回–&gt;D到右孩子到底返回–&gt; B到右孩子到底返回–&gt; A左孩子空–&gt;返回","categories":[],"tags":[]},{"title":"字符串替换","slug":"字符串替换","date":"2025-02-12T09:42:59.000Z","updated":"2025-02-28T04:01:47.648Z","comments":true,"path":"2025/02/12/字符串替换/","permalink":"http://example.com/2025/02/12/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2/","excerpt":"","text":"思路：以字符串 arr[] 000abc123abc456abc789abc*101为例。替换全部的abc1.strstr找到abc首次出现的位置2.存储abc之前的字符串000至res[]（结果数组）3.将arr清洗，去除abc及其之前的元素。arr–&gt;123abc456abc789*abc 重复以上过程，直到： arr[]:101res[0]:000res[1]:123res[2]:456res[3]:789 循环输出：res[i]+替换字符串 最后输出arr结尾。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include&lt;string.h&gt;int main() &#123; int flag = 1; //输入 char arr[100] = &#123; &#x27;\\0&#x27; &#125;; fgets(arr, 100, stdin); arr[strlen(arr) - 1] = &#x27;\\0&#x27;; int len = strlen(arr); char fin[100] = &#123; &#x27;\\0&#x27; &#125;; fgets(fin, 100, stdin); fin[strlen(fin) - 1] = &#x27;\\0&#x27;; int flen = strlen(fin); char ch[100] = &#123; &#x27;\\0&#x27; &#125;; fgets(ch, 100, stdin); ch[strlen(ch) - 1] = &#x27;\\0&#x27;; char res [100][100] = &#123; &#x27;\\0&#x27; &#125;; int i = 0; char tmp[100] = &#123; &#x27;\\0&#x27; &#125;; int head = 0, rear = 0; while (strstr(arr, fin)!=0) &#123; char* p = strstr(arr, fin); char po = p - arr;//存储相同字符串首次出现的位置 if (po == 0 &amp;&amp; i == 0) head = 1; if(po&gt;0) strncat(res[i++], arr, po);//存储此之前的源字符串 for (int j= po + flen,k=0; j &lt; len;j++) &#123;//中间字符串保留去除元素后的结果 tmp[k++] = arr[j]; &#125; memset(arr, &#x27;\\0&#x27;, sizeof(arr));//清洗源字符串 len -= (po + flen); if (po == 0 &amp;&amp; len == 0) rear = 1; strcpy(arr, tmp); memset(tmp, &#x27;\\0&#x27;, sizeof(tmp)); &#125; if (head == 1) puts(ch); for (int j = 0; j &lt; i; j++) &#123; puts(res[j]); puts(ch); &#125; puts(arr); if (rear == 1) puts(ch); return 0;&#125; 一个缺陷：puts自动输出回车，改为循环即可。","categories":[],"tags":[]},{"title":"acwing3544.寻找变化前的01序列","slug":"寻找变化前的01序列","date":"2025-02-09T11:35:44.000Z","updated":"2025-02-10T11:11:27.962Z","comments":true,"path":"2025/02/09/寻找变化前的01序列/","permalink":"http://example.com/2025/02/09/%E5%AF%BB%E6%89%BE%E5%8F%98%E5%8C%96%E5%89%8D%E7%9A%8401%E5%BA%8F%E5%88%97/","excerpt":"","text":"题目：给你一个 0101 序列，HDLC 协议处理的话，如果出现连续的 55 个 11 会补 11 个 00。例如 11111101111110，会变成 1111101011111010。现在给你一个经过 HDLC 处理后的 0101 序列，你需要找到 HDLC 处理之前的 0101 序列。例如给你 1111101011111010，你需要输出 11111101111110。 思路一：题目是还原原有的编码（要消去连续5个1之后的0） 1234567891011121314for (int i = 0; i &lt; s.size(); i++) &#123; if (s[i] == &#x27;0&#x27;) cout &lt;&lt; s[i]; //遇到0先正常输出 else &#123;//碰到1了 int j = i + 1, cnt = 1;//j判断连续，cnt用来计数 while (s[i] == s[j] &amp;&amp; j &lt; s.size()) &#123; j++; cnt++; if (cnt == 5) &#123; printf(&quot;11111&quot;); i = j; break; &#125; &#125; if (cnt != 5) cout &lt;&lt; s[i]; &#125;&#125;","categories":[],"tags":[]},{"title":"C语言输入控制","slug":"C语言输入控制","date":"2025-02-09T11:26:24.000Z","updated":"2025-02-09T11:35:20.852Z","comments":true,"path":"2025/02/09/C语言输入控制/","permalink":"http://example.com/2025/02/09/C%E8%AF%AD%E8%A8%80%E8%BE%93%E5%85%A5%E6%8E%A7%E5%88%B6/","excerpt":"","text":"一 输入一串欲输入一串字符，可使用 getchar()。样例如下： 12int ch;//char chwhile ((ch = getchar()) != EOF &amp;&amp; ch != &#x27;\\n&#x27; &amp;&amp; ch != &#x27; &#x27;) 到空格&#x2F;回车结束。 二 潜在问题当使用scanf读入时，正常情况下以空格作为结束符。若使用回车，则’\\n’会留在缓冲区中。有样例如下： 123456scanf(&quot;%d&quot;, &amp;n); while (1) &#123; if ((ch = getchar()) == &#x27;\\n&#x27;) break; arr[i] = ch - &#x27;0&#x27;; len++; &#125; 读入n之后，使用回车做结束符，会直接触发if语句导致break；可通过如下方式改进： 1234567scanf(&quot;%d&quot;, &amp;n);getchar(); while (1) &#123; if ((ch = getchar()) == &#x27;\\n&#x27;) break; arr[i] = ch - &#x27;0&#x27;; len++; &#125; 多加一次*getchar()*将回车抵消即可。","categories":[],"tags":[]},{"title":"AcWing 3841.阶乘的和","slug":"AcWing 3841.阶乘的和","date":"2025-01-22T07:55:36.627Z","updated":"2025-01-23T02:20:21.349Z","comments":true,"path":"2025/01/22/AcWing 3841.阶乘的和/","permalink":"http://example.com/2025/01/22/AcWing%203841.%E9%98%B6%E4%B9%98%E7%9A%84%E5%92%8C/","excerpt":"","text":"计算阶乘并保存：123456for (int i = 0; i &lt; 10; i++) &#123; f[i] = 1; // 初始化 f[i]。 for (int j = i; j &gt; 0; j--) &#123; // 计算阶乘。 f[i] *= j; &#125;&#125; 从f[0]到f[10]保存了0!到10!阶乘的计算过程：f[i]&#x3D;1 –&gt; f[i]&#x3D;f[i]*j (j&#x3D;i,j–) 例：1*5*4*3*2*1 计算阶乘之和判断n是否可以由1-10的阶乘中，若干个元素相加得到？ 123456789for (int i = 1; i &lt; (1 &lt;&lt; 10); i++) &#123;//遍历所有子集，i&lt;1024 int s = 0; for (int j = 0; j &lt; 10; j++) &#123; if (i &gt;&gt; j &amp; 1) &#123; // 检查第 j 位是否为 1。 s += f[j]; &#125; &#125; S.insert(s); // 插入子集和。 &#125; 题目：n&#x3D; f[x1]+f[x2]+…f[xi] （x&gt;0）即从f[1]到f[10]中，任选几项相加 如何抽出几项？ 一共有10项，可以使用二进制求解。将“1”表示为被抽出，“0”表示为未被抽出。例：000010011表示n&#x3D;f[x5]+f[x2]+f[x1] 解析代码：1for (int i = 1; i &lt; (1 &lt;&lt; 10); i++) 一共10项，即10位，若为1则对应位的f[xi]生效。10位二进制可以表示范围为0-1023，i的范围为 0000000001 ——1111111111（1—1023） 1234for (int j = 0; j &lt; 10; j++) &#123; if (i &gt;&gt; j &amp; 1) &#123; // 检查第 j 位是否为 1。 s += f[j]; &#125; j属于0-9，i&gt;&gt;j表示对i右移，&amp;1表示对1与。j&#x3D;0时，i不移动，例100010011&amp;1j&#x3D;1时，i右移1位，0100101001&amp;1j&#x3D;4时，i右移4位，0000100001&amp;1 示例： 1234int i = 5;//0000 0101for (int j = 0; j &lt; 4; j++) &#123; cout &lt;&lt; (i &gt;&gt; j &amp;1) &lt;&lt; &quot; &quot;;&#125; out: 1 0 1 0 示例2： 12int j = 45;//0010 1101cout &lt;&lt; (j &amp; 0b111) &lt;&lt; &#x27; &#x27; &lt;&lt; (j &amp; 7) &lt;&lt; &#x27; &#x27; &lt;&lt; (j &amp; 0b11)&lt;&lt;&#x27; &#x27;&lt;&lt;(j &amp; 0b1111); out:5 5 1 13 即若i的第j+1位为1，则加上f[j]，即计算阶乘之和。例如，i循环到0000010010时，s&#x3D;f[1]+f[5]。每计算完一次i则加入set中。所以，通过i从0000000000到1111111111的循环，所有的相加可能性均会被加入到set当中。","categories":[],"tags":[]}],"categories":[],"tags":[]}